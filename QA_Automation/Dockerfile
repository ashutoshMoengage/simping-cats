# ğŸ³ Advanced API Testing Framework - Production Docker Image
# ================================================================
#
# ğŸ“š FOR BEGINNERS:
# Docker creates a "container" - think of it as a lightweight virtual machine
# that packages your application with everything it needs to run:
# - Python runtime
# - Dependencies (pip packages)
# - Your code
# - Configuration files
#
# ğŸ¯ WHY USE DOCKER?
# âœ… CONSISTENCY: Runs the same on your laptop, servers, and cloud
# âœ… ISOLATION: Won't conflict with other applications
# âœ… SCALABILITY: Easy to run multiple instances
# âœ… DEPLOYMENT: Simple to deploy anywhere
#
# ğŸš€ MULTI-STAGE BUILD:
# Stage 1: Build dependencies and install packages
# Stage 2: Create minimal runtime image
# This keeps the final image small and secure!

# ========================================
# STAGE 1: BUILD STAGE (Dependencies)
# ========================================
FROM python:3.11-slim as builder

# ğŸ“ Metadata for the image
LABEL maintainer="QA Automation Team <qa@company.com>"
LABEL description="Advanced API Testing Framework with PyTest"
LABEL version="2.0.0"
LABEL documentation="https://github.com/yourcompany/pytest-framework"

# ğŸ”§ Set environment variables for Python
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# ğŸ“ Create app directory
WORKDIR /app

# ğŸ”„ Install system dependencies needed for building Python packages
# These are needed for packages like psycopg2, lxml, etc.
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    g++ \
    libc6-dev \
    libpq-dev \
    libxml2-dev \
    libxslt1-dev \
    libffi-dev \
    libssl-dev \
    curl \
    && rm -rf /var/lib/apt/lists/*

# ğŸ“¦ Copy requirements first (for better Docker layer caching)
# Docker caches layers, so if requirements.txt hasn't changed,
# it won't reinstall all packages - saves time!
COPY requirements.txt .

# ğŸ—ï¸ Install Python dependencies
# --user installs to user directory (more secure)
# --no-warn-script-location suppresses warnings
RUN pip install --user --no-warn-script-location -r requirements.txt

# ğŸ“‹ Install additional production dependencies
RUN pip install --user \
    gunicorn==21.2.0 \
    prometheus-client==0.18.0 \
    psutil==5.9.6 \
    matplotlib==3.7.2 \
    pandas==2.1.3

# ========================================
# STAGE 2: PRODUCTION STAGE (Runtime)
# ========================================
FROM python:3.11-slim as production

# ğŸ”§ Production environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    ENVIRONMENT=production \
    LOG_LEVEL=INFO \
    PYTEST_WORKERS=auto \
    ALLURE_VERSION=2.24.0

# ğŸ“ Create app directory and user
WORKDIR /app

# ğŸ‘¤ Create non-root user for security
# Running as root is a security risk in production
RUN groupadd -r pytest && useradd -r -g pytest pytest

# ğŸ”„ Install minimal runtime dependencies only
RUN apt-get update && apt-get install -y --no-install-recommends \
    libpq5 \
    libxml2 \
    libxslt1.1 \
    curl \
    wget \
    unzip \
    && rm -rf /var/lib/apt/lists/*

# ğŸ“¦ Copy Python packages from builder stage
COPY --from=builder /root/.local /home/pytest/.local

# ğŸ”§ Install Allure CLI for reporting
RUN wget -q https://github.com/allure-framework/allure2/releases/download/${ALLURE_VERSION}/allure-${ALLURE_VERSION}.tgz \
    && tar -xzf allure-${ALLURE_VERSION}.tgz \
    && mv allure-${ALLURE_VERSION} /opt/allure \
    && ln -s /opt/allure/bin/allure /usr/local/bin/allure \
    && rm allure-${ALLURE_VERSION}.tgz

# ğŸ“ Create necessary directories with proper permissions
RUN mkdir -p /app/logs /app/reports /app/data /app/config \
    && chown -R pytest:pytest /app

# ğŸ“‚ Copy application code
COPY --chown=pytest:pytest . .

# ğŸ” Switch to non-root user
USER pytest

# ğŸ”— Add local Python bin to PATH
ENV PATH="/home/pytest/.local/bin:$PATH"

# ğŸ“Š Health check endpoint
# Docker will use this to check if the container is healthy
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8080/health', timeout=5)" || exit 1

# ğŸš€ Expose ports
# 8080: Web dashboard
# 9090: Prometheus metrics
EXPOSE 8080 9090

# ğŸ“‹ Default command options
# These can be overridden when running the container
CMD ["python", "-m", "pytest", \
     "--html=reports/docker-report.html", \
     "--self-contained-html", \
     "--alluredir=reports/allure-results", \
     "--json-report", \
     "--json-report-file=reports/test-results.json", \
     "--tb=short", \
     "-v"]

# ========================================
# DEVELOPMENT STAGE (Optional)
# ========================================
FROM production as development

# ğŸ”§ Development environment variables
ENV ENVIRONMENT=development \
    LOG_LEVEL=DEBUG \
    PYTEST_ADDOPTS="-v --tb=long"

# ğŸ‘¤ Switch back to root for development setup
USER root

# ğŸ› ï¸ Install development tools
RUN apt-get update && apt-get install -y --no-install-recommends \
    git \
    vim \
    htop \
    && rm -rf /var/lib/apt/lists/*

# ğŸ“¦ Install development Python packages
RUN pip install --user \
    pytest-watch==4.2.0 \
    pytest-benchmark==4.0.0 \
    black==23.9.1 \
    flake8==6.1.0 \
    isort==5.12.0 \
    mypy==1.6.1

# ğŸ”„ Install pre-commit hooks for code quality
RUN pip install --user pre-commit==3.5.0

# ğŸ” Switch back to pytest user
USER pytest

# ğŸ¯ Development command - watch for changes and re-run tests
CMD ["pytest-watch", "--", \
     "--html=reports/dev-report.html", \
     "--alluredir=reports/allure-results", \
     "-v", \
     "--tb=short"]

# ========================================
# CI/CD STAGE (For automated testing)
# ========================================
FROM production as ci

# ğŸ”§ CI environment variables
ENV ENVIRONMENT=ci \
    LOG_LEVEL=INFO \
    CI=true \
    PYTEST_WORKERS=auto

# ğŸ‘¤ Switch to root for CI setup
USER root

# ğŸ› ï¸ Install CI tools
RUN apt-get update && apt-get install -y --no-install-recommends \
    git \
    openssh-client \
    && rm -rf /var/lib/apt/lists/*

# ğŸ“¦ Install CI Python packages
RUN pip install --user \
    coverage==7.3.2 \
    pytest-cov==4.1.0 \
    pytest-xdist==3.3.1 \
    bandit==1.7.5 \
    safety==2.3.5

# ğŸ” Switch back to pytest user
USER pytest

# ğŸ¯ CI command - comprehensive testing with coverage
CMD ["python", "-m", "pytest", \
     "--cov=utils", \
     "--cov=config", \
     "--cov-report=html:reports/coverage", \
     "--cov-report=xml:reports/coverage.xml", \
     "--cov-report=term-missing", \
     "--html=reports/ci-report.html", \
     "--self-contained-html", \
     "--alluredir=reports/allure-results", \
     "--json-report", \
     "--json-report-file=reports/ci-results.json", \
     "--tb=short", \
     "-v", \
     "-n", "auto", \
     "--strict-markers", \
     "--strict-config"]

# ========================================
# USAGE EXAMPLES FOR BEGINNERS:
# ========================================

# ğŸ—ï¸ BUILD THE IMAGE:
# docker build -t api-testing-framework .
# docker build --target development -t api-testing-framework:dev .
# docker build --target ci -t api-testing-framework:ci .

# ğŸš€ RUN THE CONTAINER:
# 
# 1. BASIC RUN (Production):
# docker run --rm -v $(pwd)/reports:/app/reports api-testing-framework
#
# 2. DEVELOPMENT MODE:
# docker run --rm -it -v $(pwd):/app -p 8080:8080 api-testing-framework:dev
#
# 3. CI MODE:
# docker run --rm -v $(pwd)/reports:/app/reports api-testing-framework:ci
#
# 4. INTERACTIVE SHELL:
# docker run --rm -it api-testing-framework bash
#
# 5. CUSTOM TEST COMMAND:
# docker run --rm api-testing-framework python -m pytest tests/api/test_users.py -v
#
# 6. WITH ENVIRONMENT VARIABLES:
# docker run --rm -e ENVIRONMENT=dev -e LOG_LEVEL=DEBUG api-testing-framework

# ğŸŒ DOCKER COMPOSE EXAMPLE:
# Create docker-compose.yml file:
# 
# version: '3.8'
# services:
#   api-tests:
#     build: .
#     volumes:
#       - ./reports:/app/reports
#       - ./logs:/app/logs
#     environment:
#       - ENVIRONMENT=dev
#       - LOG_LEVEL=INFO
#     depends_on:
#       - postgres
#       - redis
#
#   postgres:
#     image: postgres:15
#     environment:
#       POSTGRES_DB: testdb
#       POSTGRES_USER: testuser
#       POSTGRES_PASSWORD: testpass
#     ports:
#       - "5432:5432"
#
#   redis:
#     image: redis:7-alpine
#     ports:
#       - "6379:6379"
#
# Then run: docker-compose up

# ğŸ”§ OPTIMIZATION TIPS:
# 
# 1. MULTI-STAGE BUILD: Keeps final image small (200MB vs 800MB)
# 2. LAYER CACHING: Copy requirements.txt first for better caching
# 3. NON-ROOT USER: Runs as 'pytest' user for security
# 4. HEALTH CHECKS: Docker can monitor container health
# 5. MINIMAL BASE: Uses python:3.11-slim instead of full Ubuntu
# 6. CLEAN APT CACHE: Removes package manager cache to save space

# ğŸ¯ PRODUCTION DEPLOYMENT:
# 
# 1. BUILD AND TAG:
# docker build -t your-registry.com/api-testing-framework:v2.0.0 .
# docker push your-registry.com/api-testing-framework:v2.0.0
#
# 2. KUBERNETES DEPLOYMENT:
# kubectl create deployment api-tests --image=your-registry.com/api-testing-framework:v2.0.0
#
# 3. AWS ECS/FARGATE:
# Use the image in ECS task definitions
#
# 4. AZURE CONTAINER INSTANCES:
# az container create --resource-group myRG --name api-tests --image your-registry.com/api-testing-framework:v2.0.0

# ğŸ“Š IMAGE SIZE OPTIMIZATION:
# Base python:3.11-slim: ~45MB
# + Dependencies: ~150MB  
# + Application code: ~5MB
# Total optimized image: ~200MB
# (vs ~800MB with full python:3.11 image)

# ğŸ”’ SECURITY FEATURES:
# âœ… Non-root user execution
# âœ… Minimal system packages
# âœ… No unnecessary tools in production
# âœ… Health checks for monitoring
# âœ… Secrets via environment variables
# âœ… Read-only container filesystem (can be enabled)

# ğŸ¯ BENEFITS FOR TEAMS:
# âœ… CONSISTENT ENVIRONMENT: Same Python version, dependencies everywhere
# âœ… EASY DEPLOYMENT: Works on any Docker-compatible platform  
# âœ… SCALABLE: Can run multiple containers for load testing
# âœ… ISOLATED: Won't interfere with other applications
# âœ… PORTABLE: Runs on laptop, CI/CD, cloud, anywhere
# âœ… VERSION CONTROLLED: Infrastructure as code 